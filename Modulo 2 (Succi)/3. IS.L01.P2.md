Introduzione alla Unified Modeling Language, parte II
**Precedente:** [[2. IS.L01.P1]]  
**Prossima:** 
[[Modulo 2 (Succi)]]

**OBJECT ORIENTED DESIGN IN UML**
- **Design issues**:
	- **Decomposability**: capacità di un metodo di progettazione di aiutare il progettista a **scomporre** un **problema grande in sotto-problemi** più facili da risolvere.
	- **Composability**: il grado in cui un metodo di progettazione garantisce che **i componenti del programma** (moduli), una volta progettati e costruiti, possano essere **riutilizzati** per creare altri sistemi.
	- **Understandability**: la **facilità** con cui un componente del programma può essere **compreso** senza fare riferimento ad altre informazioni o altri moduli.
	- **Continuity**: l'abilità di apportare **piccole modifiche** in un programma e fare in modo che queste modifiche si manifestino con **cambiamenti** corrispondenti **in solo uno o pochissimi moduli**.
	- **Protection**: **caratteristica architetturale** che **ridurrà la propagazione degli effetti collaterali** se si verifica un errore in un dato modulo.
- **Componenti di OOD**: 
	- **Problem domain component**: sottosistemi che sono direttamente responsabili dell'implementazione delle richieste dei clienti 
	- **Human interaction component**: sottosistemi che implementano l'interfaccia utente (questo include sottosistemi GUI riutilizzabili)
	- **Task management component**: sottosistemi che sono responsabili del controllo e coordinazione di attività simultanee (le quali potrebbero essere raggruppate all'interno di uno stesso sottosistema o tra diversi sottosistemi).
	- **Data management component**: sottosistema che è responsabile per l'archiviazione e il recupero degli oggetti.
	![[Screenshot 2025-11-12 alle 15.45.09.png|319x204]]
- **Cosa distingue OOD da OOA?**: livello di dettaglio e notazioni addizionali sui diagrammi
	- In OOD sono ancora presenti i diagrammi delle classi, ma sono "perfezionati" in modo da corrispondere al design del sistema
	- In aggiunta ai diagrammi delle classi abbiamo anche:
		- Diagrammi strutturali:
			- **Diagrammi delle classi** 
			- **Object Diagrams**: si occupano di oggetti (istanze delle classi), sono assolutamente omologhi ai diagrammi di classe
		- Diagrammi comportamentali:
			- **Statechart Diagrams**: comunemente usati per gli oggetti, descrivono l'evoluzione degli stati di un qualsiasi classificatore (oggetto).
				- Mostrano il comportamento di un oggetto, in particolar modo:
					- come cambia il suo stato interno basandosi sui messaggi che riceve
					- **narrowly focused, fine-grained**: (focalizzati in modo ristretto, a grana fine), si concentrano sui dettagli minuti del comportamento di una singola entità, piuttosto che sulle interazioni dell'intero sistema.
			- **Activity Diagrams**: descrivono l'evoluzione delle attività all'interno del sistema (molto simili ai diagrammi di flusso).
			- **Sequence Diagrams**: descrivono le interazioni tra gli oggetti mettendo in risalto l'ordinamento temporale dei messaggi scambiati. Mostrano la sequenza esatta in cui avvengono le operazioni.
			- **Collaboration Diagrams**: descrivono le interazioni tra gli oggetti enfatizzando l'organizzazione strutturale dei collegamenti che li uniscono (cosa vuol dire?)
- **Stato di un oggetto**: insieme di valori che descrivono un oggetto in un momento specifico nel tempo. È determinato in base ai valori degli attributi dell'oggetto
	![[Screenshot 2025-11-12 alle 16.21.23.png|431x212]]
	- Lo stato di un oggetto [[Cambio di stato, esempio|può essere cambiato]] quando occorre un **particolare evento** 

**EXAMPLES OF STATECHART DIAGRAMS I**
https://sparxsystems.com/resources/tutorials/uml2/state-diagram.html
- **Esempio I**: states of a hockey game
	![[Screenshot 2025-11-13 alle 15.51.22.png|277x165]]
- **State diagram notation I** 
	![[Screenshot 2025-11-13 alle 16.41.43.png|168x149]]
	- **activity**: può richiedere diverso tempo e può essere interrotta. 
			- esempio: attendere input dell'utente, visualizzare una finestra, etc...
	- **action**: si verifica rapidamente (è considerata istantanea o atomica), viene eseguita totalmente oppure non viene eseguita affatto
			- esempio: impostare una flag, inviare un segnale, etc...
	- **entry**(riga 1): azione che viene eseguita NON APPENA si entra nello stato
	- **do**(riga 2): attività ancora in corso che viene eseguita quando ci si trova nello stato
	- **on**(riga 3): azione che viene eseguita in seguito ad un determinato avvenimento
	- **exit**(riga 4): azione eseguita quando si sta uscendo dallo stato
- **State diagram notation II**:
	![[Screenshot 2025-11-13 alle 16.59.23.png|356x47]]
	- **~={yellow}Event=~**: 
		- ciò che innesca il potenziale passaggio di stato
		- (quando evento specificato si verifica nello stato A, il sistema controlla se la transizione può avvenire). Vedi: DUBBI
	- **~={red}Condition=~**: 
		- il passaggio di stato avviene solamente se la condizione di guardia è vera. Se l'evento si verifica ma la condizione è falsa, la transizione non avviene e il sistema resta nello stato A. 
		- **N.B.** Se più transizioni  sono attivate partendo da uno stesso stato, da un medesimo evento e hanno condition guard diverse, e più di una guard restituisce il valore true, **solo una transizione può essere attivata**, ma la selezione è indefinita, il che può portare a un comportamento non deterministico e viene generalmente considerato un errore di progettazione (uso di else per evitare comportamente non deterministico). 
		- https://www.sciencedirect.com/topics/computer-science/guard-condition
	- **~={blue}Action=~**: 
		- processo che viene eseguito durante l'attraversamento della transizione (dopo che evento è verificato e dopo che la guardia è risultata vera)
		- deve essere rapida e non è interrompibile una volta avviata
	- Ognuna delle parti può essere omessa (?)
- **State diagram notation III**:
	![[Screenshot 2025-11-13 alle 17.46.03.png|285x91]]

**EXAMPLES OF STATECHART DIAGRAMS II: Order Management**
- **State transitions for an order**
	![[Screenshot 2025-11-13 alle 17.50.45.png|380x193]]
	- **Problema**: come fare se voglio cancellare un ordine?
		- **Soluzione 1**: transizione multiple, da ogni stato a stato "annullato"
			![[Screenshot 2025-11-14 alle 13.30.51.png|303x204]]
		- **Soluzione 2**: superstate e singola transizione
			![[Screenshot 2025-11-14 alle 13.32.47.png|302x143]]
- **State diagram notation IV**:
	![[Screenshot 2025-11-14 alle 13.34.00.png|357x153]]
**N.B.** Gli statechart diagrams non per forza si riferiscono a classi o oggetti, possono anche riferirsi a sottoinsiemi, etc...

**ACTIVITY DIAGRAMS**
https://stackoverflow.com/questions/48136302/join-and-merge-in-activity-diagram
https://www.softwareideas.net/activity-diagram-fork
https://www.geeksforgeeks.org/system-design/unified-modeling-language-uml-activity-diagrams/
https://www.uml-diagrams.org/activity-diagrams-controls.html
- **Struttura**:
	![[Screenshot 2025-11-14 alle 14.07.14.png|283x272]]
	- **Synchronization bar**: represents either two concurrent activities joining a single linear flow or a single flow branching out into concurrent activities. 
		- **Fork**: a control node that splits the flow of control into multiple, concurrent flows
		- **Join**: a control node that has multiple incoming edges and one outgoing edge and is used to synchronize incoming concurrent flows.
	- **Synchronization condition**: guarda [[DUBBI]], permette al flusso di avanzare oppure ""cambiare rotta""(?)
- **Conditions in activity diagrams**:
	![[Screenshot 2025-11-14 alle 14.46.58.png|288x179]]
	- 
