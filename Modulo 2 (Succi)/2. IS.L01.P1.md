Introduzione alla Unified Modeling Language, parte I
**Precedente:** [[1. IS.L00.Program]]  
**Prossima:** [[3. IS.L01.P2]]
[[Modulo 2 (Succi)]]

**Introduzione alla Object Oriented Programming**
- **Raggiungimento di una maggiore qualità** con la OOP, poiché consente:
	- nascondere informazioni
	- astrazione
	- modularizzazione (si dice così?)
	- riuso
- Viene utilizzata in tutte le fasi del ciclo di sviluppo:
	- OO concept modeling
	- OO analysis
	- OO design
	- OO programming
- **Semplice OO model**:
	![[Screenshot 2025-11-07 alle 16.08.36.png|231x170]]
- **Concetti chiave**:
	- **Classi e gerarchia di classi** (con ciò che ne deriva):
		- attributi
		- metodi
		- ereditarietà
		- relazioni con altre classi
	- **Oggetti**, entità concrete create a partire dalle classe (con ciò che ne deriva):
		- attributi con valori assegnati
		- relazioni istanziate
	- **Messaggi e metodi per rispondere a un messaggio**

| **Classi**                                                                                                                                                                                                                                                                                                                                                                                                     | **Istanze**                                                                                                                                                                                                                                                                                                        |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ![[Screenshot 2025-11-10 alle 11.08.19.png\|310x438]]                                                                                                                                                                                                                                                                                                                                                          | ![[Screenshot 2025-11-10 alle 11.08.26.png\|282x346]]                                                                                                                                                                                                                                                              |
| - Organizzate **gerarchicamente** usando la relazione **“is-a”** (la quale indica **ereditarietà**)<br/> - Ogni classe superiore definisce degli **attributi** (dati) e dei **metodi** (azioni) che le sottoclassi **ereditano** (es: *classe Person* ha come *attributi*: name, address, age etc…; come *metodo*: drives; *classe Car* ha  come *attributi*: make, model, etc…; come *metodo*: travels) <br/> | - **Nancy; 11 10th Av., Washington, DC; 21; XCW553245**: è un’istanza della classe person, (ha) un'associazione (usa, possiede, guida) con l'oggetto auto. <br/> - **Ferrari; 550 Maranello; I LOVE F; Red**: è un’istanza della classe Ferrari (che a sua volta è una Car, che è un Means of Transportation <br/> |
- **Istanziare le [[Glossario#Classe|classi]]**: 
	![[Screenshot 2025-10-27 alle 14.35.53.png|305x147]]
- **[[Glossario#Operazione|Operazioni]] di una classe**:invocate attraverso il [[Glossario#Message Passing|message passing]]
- **Esempio di [[Glossario#Ereditarietà|ereditarietà]]**: classe cane -> classe animale, cane eredita tutti gli attributi e metodi di animale + può ridefinirne alcuni e aggiungerne di nuovi
	![[Screenshot 2025-10-27 alle 14.35.53.png|305x147]]
- **[[GLOSSARIO#Polimorfismo|Polimorfismo]]**: esempio pratico, in matematica operazione di **somma** si usa su tipi diversi di dati/numeri (naturali, int, reali, complessi, vettori, matrici etc...). Sono presenti diversi tipi di polimorfismo: 
	- **Polimorfismo ad hoc** o **overloading**: diverse funzioni sono definite con lo stesso nome ma diversi parametri
			es: print(file), print(string), print(number)
	* **Polimorfismo generico**: template generale https://www.geeksforgeeks.org/cpp/templates-cpp/ (con puntatori devi specificare il tipo, con template no)
	* **Polimorfismo ereditario**: 
		![[Screenshot 2025-10-27 alle 15.16.31.png|279x185]]
		*senza virtual (quindi senza overriding) non riesce a capire che metodo usare e utilizza a prescindere il metodo padre (ha la precedenza)*

**UML**
- **9+ tipi di diagrammi**:
	- Class diagram
		![[Screenshot 2025-11-10 alle 12.20.11.png|213x121]]
	- Object diagram
	- Component diagram
	- Deployment diagram
	- Use case diagram
		![[Screenshot 2025-11-10 alle 12.17.39.png|219x55]]
	- Sequence diagram
		![[Screenshot 2025-11-10 alle 12.21.53.png|224x132]]
	- Collaboration diagram
		![[Screenshot 2025-11-10 alle 12.22.24.png|226x96]]
	- Statechart diagram
		![[Screenshot 2025-11-10 alle 12.20.46.png|226x139]]
	- Activity diagram
		![[Screenshot 2025-11-10 alle 12.21.19.png|212x155]]


**Object Oriented Concept Modeling**
- **Obiettivi**: capire il contesto operazionale del sistema (?), capire i requisiti del sistema 
- **Use Case Description**: scenario che descrive il filo conduttore di utilizzo di un sistema. Include:
		- **un diagramma** con **attori** che rappresentano ruoli che persone o dispositivi svolgono quando il sistema  in funzione e con **use cases** (ovvero casi di utilizzo del sistema)
		- **una descrizione scritta** che descrive le attività
			![[Screenshot 2025-10-29 alle 10.58.00.png|288x146]]
	- **Use case**:  interazione tra gli attori e il sistema, processo che soddisfa i bisogni dell'utente, descrive uno scenario (per esempio come funziona il sistema).
			- **esempio**(per un processore word): rendi il testo in grassetto, crea un indice, elimina una parola etc.. (in questo credo che caso l'attore sia l'utente) 
		- **Caratteristiche**:
			- **Granularity**: i casi d'uso possono essere di **diverse dimensioni**, possono descrivere un'azione piccola e specifica oppure un processo molto ampio che comprende diverse sotto-azioni.
			- **Often**: i casi d'uso **spesso** rappresentano/catturano una funzionalità che è direttamente visibile e utilizzabile dall'utente. Non si riferiscono ai processi interni e nascosti del sistema (non sono sicura di questa informazione)
			- **Always**: i casi d'uso devono **sempre** portare al raggiungimento di un obiettivo discreto (ben definito e separato).
			- **Always**: i casi d'uso descrivono **sempre** la funzionalità che è richiesta dall'esterno per soddisfare una qualche esigenza. 
		- **Cosa fare**:
			1. Contest capture: capire in che contesto ci si trova (comprendere e definire l'ambiente in cui il sistema opererà, i suoi confini, chi sono gli utenti e quali sono gli obiettivi...*non sono molto sicura*)
			2. **Caso d'uso** rappresenta qualsiasi azione discreta che il cliente vuole svolgere interagendo con il sistema:
				1. dagli un nome
				2. descrivilo brevemente
				3. aggiunta in seguito di dettagli (in fase iniziale NON si devono descrivere tutti i passaggi in modo dettagliato!)
		- **Use case diagram**: 
		![[Screenshot 2025-11-10 alle 14.21.59.png|256x177]]	
		- **Attori**: hanno un **ruolo** che l'utente svolge **rispetto al il sistema**, **eseguono** gli use cases, non per forza sono umani, possono avere dei guadagni dall'use case e possono partecipare direttamente in esso
		- **Textual description**: descrizione generica, step-by-step delle interazioni tra gli attori e le use case.
		- **Extends relationship**: utilizzata quando un caso d'uso può essere esteso da un altro caso d'uso (un use case è simile ad un altro ma fa **qualcosa in più**). 
			- identifica il caso d'uso base per primo
			- rappresenta ogni variazione come un'estensione del caso d'uso base (?)
			![[Screenshot 2025-11-10 alle 14.44.49.png|135x181]]
		- **Includes relationship**: definisce una parte di funzionalità usata da use case diversi, zona in cui vado a condividere comportamenti fra due use case diversi. 
			![[Screenshot 2025-11-10 alle 14.44.53.png|239x131]]

| **Includes relationship**                                                                                                                                         | **Extends relationship**                                                                                                                                                                            |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Spesso **nessun attore** associato al **common use case**. Questo perché esso **non ha senso di esistere da solo**, viene sempre chiamato da un altro caso d'uso. | **Stesso attore** performa **use case e tutte le sue estensioni**. L'**estensione** è una **variazione del flusso principale**, è sempre l'**utente principale** ad interagire con tale variazione. |
| È possibile che vi siano diversi attori per i caller cases. I casi d'uso che includono il comportamento comune possono avere attori differenti.                   | L'attore è collegato al base case. L'attore è collegato direttamente solo al caso base. Non si associa alle altre estensioni, perché sono solo un comportamento opzionale che modifica il caso base |

**OBJECT ORIENTED ANALYSIS**
1. **Extraction of classes**:
	- Esempio: Sequenza "Get the deal". Tutte le parole in grassetto sono candidati a diventare classi oppure attributi (proprietà delle classi)
		1. Enter the **user** name & **bank account**
			- user: potenzialmente potrebbe essere una classe, rappresenta una persona o entità che interagisce con il sistema
			- bank account: potenzialmente potrebbe essere una classe, rappresenta ciò che contiene i dati bancari dell'utente
		2. Check that they are valid
		3. Enter number of shares to buy & **share ID**
			- share ID: potenzialmente potrebbe essere un attributo o una classe, in particolar modo: se contiene prezzo, volume, etc... una classe, se è solo un numero un attributo
		4. Determine price
		5. Check limit
		6. Send order to **NYSE**
			- Potenzialmente potrebbe essere una classe o un attore esterno. Rappresenta un sistema esterno con cui utente interagisce. Potrebbe essere modellato come una classe di interfaccia o un attore nel diagramma dei casi d'uso. 
		7. Store **confirmation number**
			- Potenzialmente potrebbe essere un attributo. 
	- **Class diagram**: centrale per OO modeling, mostra la struttura statica del sistema. Mostra: 
		- Quali tipi di oggetto sono presenti
		- Relazioni (associazione, subtypes, dipendenza)
	- **Classe**: insieme di oggetti, definisce: **nome, attributi e operazioni**
		![[Screenshot 2025-11-10 alle 16.42.57.png|181x106]]
		
	- **[[Classe vs Tipo]]**
	
2. **Relationship between classes**
	- **Associazione**: relazione tra istanze ci classi (cioè tra gli oggetti). Indica che gli oggetti di una classe sono collegati agli oggetti di un'altra classe e che questi oggetti devono "conoscersi" per interagire tra di loro. 
			- esempio1: **a student is registered for a course**, associazione tra la classe student e la classe course. Ogni istanza di studente è collegata a una o più istanze di corso.
			- esempio2: **a professor is teaching the course**, associazione tra la classe professor e la classe course. Ogni istanza di professore è collegata all'istanza di corso che sta insegnando.
		![[Screenshot 2025-10-29 alle 15.08.08.png|261x134]]
		- **[[Glossario#Ruolo|Ruolo]]**: rappresenta un'associazione tra due classi. 
			![[Screenshot 2025-11-12 alle 09.47.45.png|63x118]]
			- Ogni associazione/relazione ha due ruoli, poiché coinvolge due classi (ha più "punti di vista"). 
			- Il ruolo è una direzione dell'associazione. 
			- Il ruolo è: **esplicitamente etichettato** (si assegna un nome descrittivo) ed **implicitamente nominato come la classe target** (se non viene specificato alcun nome di ruolo, si utilizza il nome della classe che partecipa all'associazione).
			- Il nome del ruolo chiarisce la funzione che quella classe ha nell'associazione. 
					- esempio: 
					![[Screenshot 2025-11-12 alle 09.39.43.png|345x65]]
			- Dare un nome al ruolo è obbligatorio se si tratta di oggetti facenti parte della stessa classe
					- esempio:
					![[Screenshot 2025-11-12 alle 09.51.17.png|192x68]]
		- **[[Glossario#Molteplicità|Molteplicità]]**: indica quanti oggetti possono partecipare nella relazione
			![[Screenshot 2025-11-12 alle 09.52.59.png|272x103]]
		- **[[Glossario#Responsabilità|Responsibilities]]**: astrazione delle **azioni** che una classe deve compiere (tramite i suoi **metodi**) e delle **informazioni** che deve mantenere (tramite i suoi **attributi**) per partecipare efficacemente alla logica del sistema. 
				- esempio: la classe cliente crea/inoltra un ordine, la classe ordine deve sapere chi è il cliente (?)
			![[Screenshot 2025-11-12 alle 10.04.44.png|253x126]]
			
		- **[[Glossario#Navigability|Navigability]]**: definisce in che direzione gli oggetti di una classe possono accedere o "conoscere" gli oggetti di una classe associata
				- esempio:
				![[Screenshot 2025-11-12 alle 10.05.55.png|227x85]]
				Ordine può accedere alla classe Cliente, ma Cliente non conosce ciò che è contenuto dentro Ordine. Se ci fosse stata una associazione bidirezionale: navigabilità presente in entrambe le direzioni, quindi entrambe le classi possono accedere l'una all'altra (...)
				![[Screenshot 2025-11-12 alle 10.09.54.png|374x199]]
	- **Riassunto**: notazione base per le associazioni
		![[Screenshot 2025-11-12 alle 10.13.58.png|249x118]]
	- **Classi di associazione**: utili se gli attributi non appartengono alle classi coinvolte, ma a quella di associazione.![[Screenshot 2025-11-12 alle 10.15.45.png|351x154]]
		
3. **Classi e oggetti**: (Credo si parli del punto 3, quindi "define a class hierarchy") una classe definisce la struttura di un gruppo di oggetti. 
	- **Definisce**: nomi, attributi e operazioni
		![[Screenshot 2025-11-12 alle 10.27.17.png|293x154]]
	- **Esempio di classi e oggetti**:
		![[Screenshot 2025-11-12 alle 10.34.33.png|287x151]]
4. **Attributi**: rappresentano alcuni dati della classe.
		![[Screenshot 2025-11-12 alle 10.39.57.png|137x139]]
	- **Differenza tra attributi e associazioni**: 
		- Dal punto di vista **concettuale**: la differenza non è enorme, entrambi rappresentano una connessione o una proprietà di una classe. 
			- **Attributi**: riguardano solitamente dati monovalore.
					- esempio: una persona ha un solo nome, un solo indirizzo, la *molteplicità è solitamente 0...1 (uno o nessuno)*
			- **Associazioni**: riguardano le relazioni tra due classi diverse, possono essere molteplici e sfaccettate.
		- Dal punto di vista **della specifica/dell'implementazione**: 
			- **Attributi**: 
				- **Memorizzano** il valore del dato direttamente o per copia
				- **Nessuna condivisione**: quando sono presenti due oggetti, l'attributo di un oggetto è indipendente dall'attributo dell'altro. Se si cambia il nome di un oggetto, non si cambia il nome dell'altro.
				- **Navigabilità**: implicita e unidirezionale, si accede alla classe e poi all'attributo
			- **Associazione**: 
				- Nel codice viene implementata **memorizzando un riferimento** (puntatore) a un altro oggetto di un'altra classe
				- **Condivisione possibile**: se due oggetti Order hanno un'associazione con lo stesso oggetto Customer, entrambi gli Order fanno riferimento allo stesso Customer. Se si modifica il Customer (es. si cambia l'indirizzo), la modifica è visibile da entrambi gli Order. 
			- **Tipo di dato**:
				- **Attributi**: quasi sempre usati per tipi di dati semplici (es: numeri, stringhe, etc...).
				- **Associazioni**: usate per classi che rappresentano entità complesse (es. Customer, Department, Product, etc...).
5. **Operazioni**: processi che una classe sa di dover svolgere
		![[Screenshot 2025-11-12 alle 10.58.48.png|239x123]]
	- **Tipo di operazioni**: 
		- **Query**: ritorna valori senza modificare lo stato interno della classe. Possono essere eseguite in qualsiasi ordine.
		- **Modifier**: ritorna valori (immagino) modificando però lo stato interno della classe.
			- **Ottenere messaggi**: associato alla query
			- **Impostare messaggi**: associato a modifier
6. **Aggregazione**: forma speciale di associazione. Le componenti sono parti di un oggetto aggregato (es: un'auto ha un motore e ruote come sue componenti), l'aggregazione è *transitiva*.
	![[Screenshot 2025-10-30 alle 15.06.57.png|245x143]]
	- **Composizione**: le componenti appartengono a un unico insieme, queste componenti vivono e muoiono con esso (?)
	- **Come distinguere tra aggregazione e composizione?**: chiedersi se un determinato elemento fa parte di... + l'operazione sull'insieme influisce anche sulle sue parti.
			- esempio: **Aggregation** implies a relationship where **the child can exist independently of the parent**. Example: **Class** (parent) and **Student** (child). <mark style="background: #FFF3A3A6;">Delete the Class and the Students still exist</mark>. **Composition** implies a relationship where **the child cannot exist independent of the parent**. Example: **House** (parent) and **Room** (child). <mark style="background: #FFF3A3A6;">Rooms don't exist separate to a House</mark>.
			![[Screenshot 2025-11-12 alle 11.09.29.png|262x106]]
			![[Screenshot 2025-11-12 alle 11.09.47.png|182x168]]
7. **[[Generalization VS Extension|Generalization VS Extension]]**
8. **Classe, instantiation e generalization**
	- **Instantiation and generalization**:
		![[Screenshot 2025-11-12 alle 11.26.54.png|0x0]]
	- **Classe**: insieme di oggetti che condividono stesse proprietà e stessi comportamenti
		- Diagramma di classe **con ereditarietà**:
			![[Screenshot 2025-11-12 alle 11.33.41.png|0x0]]
		- **Come definire le classi?**
			1. cerca nomi in Use Cases
			2. definisci una classe per ogni nome
			3. individua il set di regole che determina perché certi oggetti appartengono alla classe (e perché altri no)
			4. aggiungi associazioni per modellare le relazioni 
			5. pensa alle relazioni dei sottoinsiemi per costruire generalizzazioni
		- **Appartenenza alla classe**:
			- **Appartenenza implicita per via di regole** (traduzione meh): 
				- **regole** definiscono le condizioni per essere un membro della classe
				- se conosciamo le **proprietà** (attributi) di un oggetto, possiamo usare le regole per **assegnarlo alla classe corretta**.
						- es: Se ho un oggetto con `ruote=4` e `tipo_veicolo=camion`, viene assegnato alla classe `Truck` (Camion)
			- **Appartenenza esplicita per enumerazione** (traduzione meh2):
				- **Instantiation** definisce l'appartenenza alla classe
				- **sorge un problema**: se un oggetto è definito esplicitamente come membro, è difficile implementare controlli o restrizioni. Se si aggiunge o rimuove un oggetto, la definizione della classe deve essere modificata manualmente.
		- **Cambiare la classe**: UML dà all'oggetto la possibilità di cambiare le classi dinamicamente (?), questo è fatto in C++ e Java con una classe base comune per poi cambiare gli oggetti puntati con i costruttori adeguati *(cosa significa questa cosa?)*
	- **Instantiation**: creazione di un singolo oggetto che appartiene alla classe
	- **Generalization**: descrive una relazione in cui una classe è un sottoinsieme di un'altra classe.
		![[Screenshot 2025-11-03 alle 10.53.38.png]]
		- **Estensione e restrizione**: attributi e operazioni di una classe antenata sono ereditati dalla sottoclasse
			- **estensione**: aggiunta di nuovi attributi o nuove operazioni
			- **restrizione**: restrizioni addizionali applicati agli attributi ereditati 
					- **esempio di restrizione**: classe antenata (superclasse) = ellisse, la quale ha due attributi chiave asse maggiore e asse minore. Questi due assi possono avere lunghezza arbitraria. La sottoclasse dell'ellisse è il cerchio, eredita quindi tutti gli attributi di ellisse ma ha una restrizione: i due assi devono avere lunghezza uguale. Il cerchio *impone* quindi una restrizione sugli attributi ereditati.
9. **Ereditarietà multipla**:
	![[Screenshot 2025-11-12 alle 11.42.51.png|0x0]]
	- Da **evitare**, per ristrutturare il diagramma utilizzare tecniche quali **delegation e aggregation**:
		![[Screenshot 2025-11-12 alle 11.52.15.png|376x170]]
		
		![[Screenshot 2025-11-12 alle 11.53.46.png|414x167]]

		![[Screenshot 2025-11-12 alle 11.54.30.png|398x223]]
10. **Virtual inheritance**:
	Quando TextBook **eredita da due classi** (EducationalTool e Book) che a loro volta **ereditano dalla stessa classe base** (ItemToSell), TextBook si ritrova con **due copie dell'attributo price**. Questo crea **ambiguità**: quale price dovrebbe usare TextBook? Quello ereditato attraverso EducationalTool o quello attraverso Book?
	
	![[Screenshot 2025-11-03 alle 12.29.42.png|197x136]]
	
```
	Class ItemToSell {
	double price;
	} ;

	Class EducationalTool : public ItemToSell {
	};

	Class Book : public ItemToSell {
	};

	Class TextBook : public EducationalTool, public Book {
	};
	
```

**VIRTUAL INHERITANCE**

```
Class ItemToSell {
	double price;
};

Class EducationalTool : virtual public ItemToSell {
};

Class Book : virtual public ItemToSell {
};

Class TextBook: public EducationalTool, public Book {
};
```

![[Screenshot 2025-11-03 alle 12.32.58.png|197x113]]

Quando EducationalTool e Book dichiarano che ereditano virtualmente da ItemToSell, stanno dicendo al compilatore: "Se qualcuno erediterà da me e da un'altra classe che eredita anche virtualmente da ItemToSell, fai in modo che la classe base ItemToSell venga inclusa solo una volta". In questo modo, la classe TextBook (che eredita da entrambi) avrà una sola copia condivisa della classe ItemToSell e, di conseguenza, un solo attributo price. (GEMINI)